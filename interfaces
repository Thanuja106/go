package main

import "fmt"
type shape interface{
  area()int
  perimeter()int
}
func main() {
  var s shape
  fmt.Println("area",s)
 }
 OUTPUT:
 area <nil>
 /====================================================================================
 package main

import "fmt"
type shape interface{
  area()int
  perimeter()int
}
func main() {
  var s shape
  fmt.Println("area",s.area())
}
--->output ispanic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x487193]

goroutine 1 [running]:
main.main()
    /home/runner/main.go:10 +0x23
exit status 2
/====================================================================================
package main//1st way interfaces

import "fmt"
type shape interface{
  area() float32
  perimeter() float32
}
type  measure struct{
  width float32
  breadth float32
} 
func(m measure)area()float32{
  return m.width*m.breadth
}
func(m measure)perimeter()float32{
  return m.width*2+m.breadth*2
}
func main() {
  var s shape
   s=measure{3.2,2.5}
   r:=measure{3.2,52.5}
   fmt.Println(s.area(),s.perimeter(),r)
}
output:
8 11.4 {3.2 52.5}
/==========================================================================================
package main//2nd way of interface

import "fmt"
type I interface{
  m()string
}
type t struct{
  name string
}
func(t1 t)m()string{
  return t1.name
}
func hello(i I){
  fmt.Println(i.m())
}
func main() {
  hello(t{"hai"})
}
OUTPUT:
hai
/==================================================================================================
package main//3rd way of writing interfaces

import "fmt"
type I interface{
  m()string
}
type t struct{
  name string
}
func(t1 t)m()string{
  return t1.name
}
func hello(i I){
  fmt.Println(i.m())
}
func main() {
 tt:=t{"hai"}
 hello(tt)
}
output:hai
/===================================================================================================
type  shape interface{
  m1()int
}
type  object interface{
  m2()int
}
type   cube struct{
  side int
}
func main(){
  var s shape
  var  o object
  s=cube{10}//here it is the big process to implement the interfaces instead of this we can write below as follows
  o=cube{20}
  f(s)
  f1(o)
}
func(c cube)m1()int{
  return c.side+2
}
func(c cube)m2()int{
  return c.side+20
}
func f(s shape){
  fmt.Println(s.m1())
}
func f1(o object){
  fmt.Println(o.m2())
OUTPUT:
12
40
/========================================================================================
package main

import "fmt"
type shape interface{
  m1()int
}
type object interface{
  m2()int
}
type cube struct{
  side int
}

func main(){
  var s shape=cube{10}
   c:=s.(cube)///////////like this
   value,ok:=s.(cube)
   fmt.Println(value,ok)
    fmt.Println("m1",c.m1(),c.m2())
}
func(c cube)m1()int{
return c.side+2
}
func(c cube)m2()int{
return c.side+28
}
OUTPUT:
{10} true
m1 12 38
/====================================================================================================
TYPE ASSERTIONS
package main

import "fmt"

func main() {
var val interface{
  }=98.98
  myfunc(val) 
  var val1 interface{
  }="helo"
  myfunc(val1)
  //fmt.Println("type of the interface %T",)
}
func myfunc(a interface{}){
  value,ok:=a.(float64)
  fmt.Println(value,ok,a)
  
}
OUTPUT:
98.98 true 98.98
0 false helo
/====================================================================================================












